<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Testing - Tag - &lt; 言われない ></title><link>https://novaannabella.github.io/the_unspoken/ja/tags/testing/</link><description>Testing - Tag - &lt; 言われない ></description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><managingEditor>nova@scene.to (Nova Annabella)</managingEditor><webMaster>nova@scene.to (Nova Annabella)</webMaster><lastBuildDate>Wed, 31 May 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://novaannabella.github.io/the_unspoken/ja/tags/testing/" rel="self" type="application/rss+xml"/><item><title>テストエベネン：正しいバランスを見つける</title><link>https://novaannabella.github.io/the_unspoken/ja/test_level/</link><pubDate>Wed, 31 May 2023 00:00:00 +0000</pubDate><author>Nova Annabella</author><guid>https://novaannabella.github.io/the_unspoken/ja/test_level/</guid><description>テストレベル：適切なバランスを見つける 序論 テストのテーマは、今日までにまだ新たな領域で、解釈に多くの自由な空間を提供しています。伝統的な テストピラミッドは問い直され、新たなテストピラミッドが生まれました。私の考えでは、必要なのは テストピラミッドではなく、何をテストするべきかについて明確な理解であると言えます。下位レベルのテストはしばしば あまり意味を成さない。焦点は主に振る舞いのテストに置かれるべきで、確認するために API またはUIが意図した通りに動作するようです。可能なテストタイプの包括的な概観はここで見つけることができます: Martinfowler Testing.
レベル1 - モックテスト＆単体テスト 目標：アプリケーション内の最小限のテスト可能なソフトウェア部品を実行し、それらが期待通りに機能するか確認する。 モックテストとユニットテストは逆効果であり、開発プロセスを頻繁に妨げる可能性があります。これらのテストはしばしばコンテクストか ら切り離され、現実に対する関連性が少ないものです。それらは、既存のユニットテストを通じて不要な機能を維持するためだけに使われることがよくあります。モックが追加されると、それは自己満足になります。モックテストの期待される結果は、元のモックで定 義されたものに限定されます。エンドユーザーは内部機能に興味がありません。例えば、ログインシナリオのloginUser(name, password, securityAlgorithmus)で、ユニットテストがsecurityAlgo rithmパラメーターに対するnullチェックを行うと、ユーザーはsecurityAlgorithmパラメーターを設定できないため、テストが過度に行われることになります。
レベル2 - インテグレーションテスト 目的：コンポーネント間の通信路と相互作用を検査し、インターフェースの欠陥を検出する。 統合テストは、アプリケーションの各部分の性能と独立性について貴重な洞察を提供します。モックが少ないほど、テストは理解しやすくなります。しかし、なお、テス トにはコンテキストが欠けており、統合テストがただのユニットテストにすぎない、モックの少ないバージョンである可能性があります。
レベル3 - コンポーネントテスト 目的：テスト対象のソフトウェアの範囲を検証対象のシステムの一部に制限し、システムを内部コードインターフェースを介して操作し、テストダブルを使用してテスト対象のコードを他のコンポーネントから隔離します。 コンポーネントテストは、アプリケーシ ョンの品質と性能について多くの情報を提供します。モックをテストする代わりに、あなたはついにあなたのアプリケーションをテストします。コンポーネントテストとエンドツーエンドテストの間の境界はそれほど重要ではありません。良好なテスト環境では、それ らの間の境界がしばしばぼやけて、実際の挙動を隔離された無関係な機能の代わりにテストすることが可能になります。しかし、追加のテストクラス(コンポーネントスタブ、フェイク、モックなど)を製品コードに作成することで、追加のメンテナンス作業が発生す る可能性があります。
レベル4 - 契約テスト このコードブロックの目的は、外部サービスの境界でのインタラクションをチェックし、それが消費者サービスの契約要求を満たしていることを確認することです。
契約テストはよくコンポーネントテストに似ており、彼らの間にはわずかな違いしかありません。いくつかの開発者はこれらのテストをPactテストと関連付け、それは基本的にサーバーが介在する単体テストとして機能します。しかし、これらのテストを維持するコストはそれだけの価値がないかもしれません。例えば、PactテストはREST-API loginUser?name=aa&amp;amp;password=bb)をテストし、前にPactサーバーにアップロードされたJSONスキーマ応答を期待することができます。このスキーマは静的であり、APIの応答で誤った日付形式やタイムゾーンなどのエラーに対して脆弱である可能性があります。その影響は大きいかもしれません。
レベル5 - エンドツーエンドテスト（別名ブラックボックステスト） 目的：システムが外部要件を満たし、目標を達成しているかを確認するために、システム全体を 始めから終わりまでテストする。 エンドツーエンドテストは信頼性があり、堅牢です。テスト環境の構築の課題を克服すると、その 努力は報われます。これらのテストは実際の動作をシミュレートし、モックの必要性を排除します。エラーはめったに 発生せず、ローカルでの再現も容易になります。手間のかかるデバッグや本番環境でのログの取得 が大幅に減少し、稀な事件も同様に減少します。開発者はまれに、もしある場合でも、実データを扱うことはありませんが、 これにより責任が軽減され、焦点が高まります。さらに、自動ソフトウェアアップデートのような自動化が、 行動が既にテストされたという事実を考慮に入れて実施を容易にします。他にも利点があります！ テストが 再利用可能な形式で書かれていれば、負荷テストに統合することができ、機能の全体像を得ることができます。これらのテストはまた、常時本番環境で 実行され、各種ワークフローの状況に対するリアルタイムの洞察を提供します。部分システム、例えば 外部のRESTサービスがオフラインになると、影響を受けるユーザワークフローがすぐに特定できます。
結論 要約すると、テストはソフトウェア開発の重要な側面であり、テストレベルの選択はアプリケーションの具体的な要求と目標に依存します。モックテストやユニットテストはその効果が限定的であるかもしれませんが、インテグレーションテストとコンポーネントテス トでは、アプリケーションの振る舞いやパフォーマンスについて価値ある洞察を提供します。コントラクトテストは外部サービスとの交互作用を確認するのに役立ちますが、それとコンポーネントテストとの区別は最小限になるかもしれません。最終的に、エンドツー エンドテストはシステムの機能に対する最大限の信頼を提供し、アプリケーション全体の包括的なテストを可能にします。適切なテストレベルを選択し、それらを効果的に組み合わせることにより、開発者はソフトウェアの品質、信頼性、強靭性を保証することができ ます。
連絡先 GitHubの問題。</description></item></channel></rss>