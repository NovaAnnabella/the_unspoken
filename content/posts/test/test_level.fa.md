---
title: "سطوح تست: پیدا کردن تعادل صحیح"
date: 2023-05-31
author: "Nova Annabella"
slug: test_level
tags: [ Testing, Software Testing, Test Levels, Mock Tests, Unit Tests, Integration Tests, Component Tests, Contract Tests, End-to-End Tests ]
categories: [ Technology, Software Development, Quality Assurance ]
description: "یافتن تعادل مناسب در انتخاب سطوح تست مناسب برای تست نرم افزار"
draft: false
images:
  - "/images/content/martin_fowler_testing.png"
card: "summary_large_image"
---


# آزمون سطوح: یافتن تعادل صحیح

[![testebenen](/images/content/martin_fowler_testing.png)](https://martinfowler.com/articles/microservice-testing/)

### مقدمه

موضوع تست کردن به نظر می‌رسد تا به امروز هنوز زمینه نو و با فضای زیادی برای تفسیر باقی است. پرامید تست سنتی به چالش کشیده شده و پرامیدهای تست جدیدی پدید آمده اند. به نظر من، نیازی به پرامید تست نیست، بلکه یک درک روشن از آنچه باید تست شود لازم است. تست‌های در سطوح پایینتر اغلب کمتر موثر هستند. تمرکز باید بیشتر بر تست کردن رفتار باشد ، تا اطمینان حاصل شود که 
API
یا UI همانطور که مورد نیاز است کار می‌کند. یک نمای کامل از انواع تست‌های ممكن را می‌توانید در اینجا پیدا کنید:
[Martinfowler Testing](https://martinfowler.com/articles/microservice-testing/).

### سطح 1 - تست های شبیه سازی و تست واحد

هدف: اجرای کوچک‌ترین قطعات قابل تست نرم‌افزار در برنامه برای مشخص کردن اینکه آیا آنها مطابق انتظار کار می‌کنند. تست‌های
Mock و Unit می‌توانند مخرب باشند و برنامه ریزی توسعه را بسیار مختل کنند. این تست‌ها اغلب از زمینه جدا هستند و ارتباط کمی
با واقعیت دارند. آنها اغلب فقط برای حفظ عملکردهای غیرضروری با استفاده از تست‌های Unit وجود دارند. به محض اینکه Mockها
افزوده می‌شوند، تبدیل به یک فعالیت خودمختار می‌شود. نتایج مورد انتظار از تست‌های Mock محدود به آنچه در Mock اصلی تعریف
شده است. کاربران نهایی به عملکرد داخلی علاقمند نیستند. به عنوان مثال، در یک سناریوی ورود به سیستم `loginUser(name,
password, securityAlgorithmus)` . اگر تست Unit بررسی Null را روی پارامتر `securityAlgorithm` انجام دهد، از حد زیاد
می‌تستد، زیرا کاربران قادر به تنظیم پارامتر `securityAlgorithm` نیستند.

### سطح 2 - آزمون ادغام

هدف: بررسی روشهای ارتباطی و تعاملات بین اجزای مختلف برای شناسایی اشکالات رابط کاربری. تست‌های یکپارچه‌سازی دیدگاه‌های
ارزشمندی در مورد کارایی و استقلال بخش‌های مختلف برنامه ارائه می‌دهند. با وجود مسخره‌های کمتر، این تست‌ها قابل درک تر
می‌شوند. با این حال، همچنان به آن‌ها زمینه‌ای می‌فهماند و خطر وجود دارد که تست‌های یکپارچه‌سازی فقط تست‌های واحد مخفی
شده با مسخره‌های کمتر باشند.

### سطح 3 - تست کامپوننت

هدف: محدود کردن حوزه نرم افزار آزمایش شده به بخشی از سیستم قابل بررسی، دستکاری سیستم
از طریق رابطهای کد داخلی و استفاده از تست دابلها برای جدا کردن کد قابل آزمایش از سایر
کامپوننت‌ها.

تست‌های کامپوننت اطلاعات بسیاری را درباره کیفیت و عملکرد برنامه ارائه می‌دهند. در عوض
مسخره‌ها، بالاخره برنامه خود را آزمایش می‌کنی. مرز بین تست‌های کامپوننت و تست‌های end-to-end
مهم نیست. با یک محیط تست خوب، مرزها بین آن‌ها اغلب مبهم می‌شوند، بنابراین امکان تست کردن رفتار واقعی
به جای توابع مجزا و بی‌سیاق فراهم می‌شود. با این حال، ایجاد کلاس‌های تست اضافی مانند کامپوننت‌های Stub، Fakes و Mocks در کد تولیدی می‌توانید سربار تعمیر و نگهداری اضافی را به همراه داشته باشد.

### سطح 4 - تست قرارداد

هدف از این بلوک کد بررسی تعاملات در حاشیه یک سرویس خارجی و اطمینان از این است که اون سرویس با خواسته های قرارداد یک سرویس مصرف کننده مطابقت دارد.

آزمایش های قرارداد اغلب شبیه به آزمایش های کامپوننت هستند، و تفاوت بین آنها کم است. برخی از توسعه دهندگان این آزمایش ها را با آزمایش های Pact مرتبط می کنند، که در اصل به عنوان آزمایش های واحد با یک سرور در میان عمل می کنند. با این حال، زحمت حفظ این آزمایش ها ممکن است ارزشمند نباشد. به عنوان مثال، یک آزمایش Pact ممکن است REST-API `loginUser?name=aa&password=bb)` را آزمایش کند و انتظار یک پاسخ JSON-Schema را داشته باشد که قبلاً بر روی سرور Pact بارگذاری شده است. این طرح static است و در معرض خطاهایی مثل فرمت های تاریخ اشتباه یا مناطق زمانی در پاسخ API است. تأثیرات منفی ممکن است فراگیر باشند.

### سطح 5 - تست های از ابتدا تا انتها (همچنین تست های جعبه سیاه نامیده می شوند)

هدف: بررسی اینکه آیا یک سیستم نیازهای خارجی را برآورده می کند و اهداف خود را با تست کردن کل سیستم از ابتدا تا انتها
برآورده می کند. تست های پایان به پایان مطمئن و ماندگار هستند. به محض غلبه بر موانع ساخت محیط تست، تلاش صرف شده می آید.
این تست ها رفتار واقعی را شبیه سازی می کنند و نیاز به Mocks را از بین می برند. خطاها کمتر رخ می دهند و در محل به راحتی
قابل تکرار است. اشکالات گسترده و رهبری بر روی پروتکل ها در تولید به طور عمده از بین می رود، همچنین حوادث نادر. توسعه
دهندگان کمتر کار می کنند، اگر اصلا با داده های تولیدی، که مسئولیت را کاهش می دهد و تمرکز را افزایش می دهد. علاوه بر این،
اتوماسیون هایی مانند بروزرسانی نرم افزار خودکار اجرا را ساده می کند، زیرا رفتار از قبل تست شده است. مزایای بیشتری وجود
دارد! به محض اینکه تست ها به صورت قابل استفاده مجدد نوشته شده اند، می توانند در تست های بار برای دریافت یک تصویر جامع
از قابلیت عملکرد یکتا شامل شوند. این تست ها همچنین می توانند به طور مداوم در محیط تولید اجرا شوند و دیدگاه های زمان
واقعی در وضعیت گردش کارهای مختلف ارائه دهند. اگر یک سیستم جزئی، مانند یک سرویس REST خارجی، آفلاین برداشته شود، بلافاصله
می توان شناخت که کدام گردش کارهای کاربر تحت تأثیر هستند.

### نتیجه گیری

به طور خلاصه، تست یک جنبۀ ضروری توسعۀ نرم افزار است و انتخاب مراحل تست بستگی به نیازها و اهداف خاص برنامه دارد. در حالی که تست های مک و یونیت ممکن است در اثربخشی آنها محدود باشند، تست های ادغام و تست های اجزاء دیدگاه های بی قیمتی در رفتار و عملکرد برنامه ارائه می دهند. تست های قرارداد کمک می کنند تا تعامل باخدمات خارجی را بررسی کنند، اما حدود آن با تست های اجزاء ممکن است حداقل باشد. در نهایت، تست های انتهای-به-انتها اطمینان بالاترین را در عملکرد سیستم ارائه می دهند و اجازه انجام تست های جامع کل برنامه را می دهند. با انتخاب مراحل تست مناسب و ترکیب کارآمد آنها، توسعه دهندگان می توانند به کیفیت، قابلیت اطمینان و استحکام نرم افزار خود تضمین دهند.

### تماس

[مسائل گیتهاب](https://github.com/NovaAnnabella/the_unspoken/issues/new/choose).
