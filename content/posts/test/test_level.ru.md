---
title: "Уровни тестирования: Найти правильный баланс"
date: 2023-05-31
author: "Nova Annabella"
slug: test_level
tags: [ Testing, Software Testing, Test Levels, Mock Tests, Unit Tests, Integration Tests, Component Tests, Contract Tests, End-to-End Tests ]
categories: [ Technology, Software Development, Quality Assurance ]
description: "Найти правильный баланс при выборе подходящих уровней тестирования для тестирования программного обеспечения"
draft: false
images:
  - "/images/content/martin_fowler_testing.png"
card: "summary_large_image"
---


# Уровни тестирования: Найти правильный баланс

[![testebenen](/images/content/martin_fowler_testing.png)](https://martinfowler.com/articles/microservice-testing/)

### Введение

Тема тестирования до сих пор кажется неизведанной территорией с большим пространством для интерпретации. Традиционная пирамида тестирования была поставлена под сомнение, и появились новые пирамиды тестирования. По моему мнению, не требуется пирамиды тестирования, а нужно четкое понимание того, что должно быть протестировано. Тесты на более низких уровнях часто менее информативны. Основное внимание должно быть сосредоточено на тестировании поведения, чтобы убедиться, что API или пользовательский интерфейс работают как предполагается. Общий обзор возможных видов тестирования можно найти здесь: [Тестирование Мартина Фаулера](https://martinfowler.com/articles/microservice-testing/).

### Уровень 1 - Тесты-заглушки и модульные тесты

Цель: Протестировать наименьшие проверяемые составляющие программного обеспечения в приложении, чтобы убедиться, что они функционируют так, как ожидалось.

Мок-тесты и модульные тесты могут быть контрпродуктивными и часто мешают процессу разработки. Эти тесты часто
отделены от контекста и имеют мало отношения к реальности. Они часто служат только для поддержания ненужных функций через существующие модульные тесты. Как только добавляются моки, это становится своего рода занятием. Ожидаемые
результаты от мок-тестов ограничиваются тем, что было определено в исходном моке. Конечные пользователи
не интересуются внутренними функциями. Например, в сценарии
входа в систему `loginUser(name, password, securityAlgorithmus)`. Если модульный тест проводит проверку на Null
на параметр `securityAlgorithm`, то тестируется слишком много, так как пользователи не могут
установить параметр `securityAlgorithm`.

### Уровень 2 - Тестирование интеграции

Цель: Проверка каналов связи и взаимодействий между компонентами для обнаружения дефектов интерфейса.

Интеграционные тесты дает ценные сведения о производительности и независимости различных частей приложения. Тесты становятся более понятными с меньшим количеством макетов. Однако у них все еще отсутствует контекст, и существует риск, что интеграционные тесты просто замаскированные unit-тесты с меньшим количеством макетов.

### Уровень 3 - Тест компонента

Цель: Ограничение объема тестируемого программного обеспечения до части проверяемой системы, манипулирование системой
через внутренние интерфейсы кода и использование тестовых двойников для изоляции тестируемого кода от других
компонентов.

Тестирование компонентов предоставляет массу информации о качестве и производительности приложения. Вместо
подставок, вы наконец-то тестируете ваше приложение. Граница между тестированием компонентов и end-to-end тестированием не
значительна. С хорошей средой тестирования границы между ними часто размываются, что позволяет тестировать реальное
поведение вместо изолированных и контекстно непривязанных функций. Однако создание дополнительных
тестовых классов, таких как заглушки компонентов, подделки и подставы в продуктовом коде, может повлечь за собой дополнительные затраты на обслуживание.

### Уровень 4 - Тестирование контракта

Цель этого блока кода заключается в проверке взаимодействий на границе внешнего сервиса и
обеспечении его соответствия требованиям контракта потребительского сервиса.

Тесты контрактов часто напоминают компонентные тесты, и разница между ними минимальна. Некоторые разработчики
ассоциируют эти тесты с Pact-тестами, которые по сути действуют как модульные тесты с сервером посередине. Однако
усилия, необходимые для поддержания этих тестов, могут быть неоправданными. Например, Pact-тест может проверять
REST-API `loginUser?name=aa&password=bb)` и ожидать ответ JSON-схемы, которая была ранее загружена на Pact-сервер.
Эта схема статична и подвержена ошибкам, таким как неверные форматы даты или часовые пояса в
API-ответе. Негативные последствия могут быть огромными.


### Уровень 5 - Конечные тесты (также называемые черными ящиками)

Цель: Проверка того, соответствует ли система внешним требованиям и достигает ли своих целей, тестируя всю систему от
начала до конца.

End-to-End тесты надежны и устойчивы. Как только преодолены препятствия создания тестовой среды, усилия оправдывают
себя. Эти тесты имитируют реальное поведение и устраняют необходимость в макетах. Ошибки возникают реже и их проще
воспроизвести локально. Сложная отладка и ведение журналов в производственной среде в основном исключены, как и редкие
инциденты. Разработчики реже работают с производственными данными, если вообще работают, что снижает ответственность и
увеличивает концентрацию. Кроме того, автоматизация, такая как автоматические обновления программного обеспечения,
облегчает проведение, поскольку поведение уже было протестировано. Есть и другие преимущества! Как только тесты написаны
в форме, которую можно использовать снова и снова, они могут быть интегрированы в нагрузочные тесты, чтобы получить
полную картинку функционала. Эти тесты могут также быть проведены непрерывно в производственной среде и предоставлять
информацию в реальном времени о состоянии различных рабочих процессов. Если часть системы, например, внешний REST-сервис,
выходит из строя, можно сразу определить, какие рабочие процессы пользователей затронуты.

### Вывод

В заключение, тестирование является существенным аспектом разработки программного обеспечения, и выбор уровней
тестирования зависит от специфических требований и целей приложения. В то время как макетные тесты и модульные тесты
могут быть ограничены в своей эффективности, интеграционные тесты и тесты компонентов предоставляют ценные сведения о
поведении и производительности приложения. Контрактные тесты помогают проверять взаимодействие с внешними службами, но
твое отграничение от тестов компонентов может быть минимальным. В конце концов, тесты с начала до конца обеспечивают
наибольшую степень доверия в функциональность системы и позволяют проводить всеобъемлющие тесты всего приложения. Путем
выбора подходящих уровней тестирования и их эффективной комбинации разработчики могут обеспечить качество, надежность и
устойчивость вашего программного обеспечения.

### Контакт

[GitHub Проблемы](https://github.com/NovaAnnabella/the_unspoken/issues/new/choose).
